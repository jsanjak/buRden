# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The c-alpha statistic
#' @param data A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param status A vector of binary phenotype labels.  0 = control, 1 = case.
#' @examples
#' data(rec.ccdata)
#' status = c( rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases) )
#' rec.ccdata.calpha = cAlpha(rec.ccdata$genos,status)
cAlpha <- function(data, status) {
    .Call('buRden_cAlpha', PACKAGE = 'buRden', data, status)
}

#' Single-marker association test based on the chi-squared statistic
#' @param ccdata A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param ccstatus A vector of binary phenotype labels.  0 = control, 1 = case.
#' @return A vector of -log10(p-values) from a chi-squared test with one degree of freedom.  The chisq test is based on a 2x2 table of minor vs major allele counts in cases vs. controls.
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #Note that the result should be very very similar to logistic regression under additive model...
#' rec.ccdata.chisq = chisq_per_marker(rec.ccdata$genos, status)
chisq_per_marker <- function(ccdata, ccstatus) {
    .Call('buRden_chisq_per_marker', PACKAGE = 'buRden', ccdata, ccstatus)
}

#' Obtain permutaion distribution of the ESM_K statistic for case/control data
#' @param ccdata A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param ccstatus A vector of binary phenotype labels.  0 = control, 1 = case.
#' @param nperms Number of permutations to perform
#' @param k Number of markers to use for ESM_K statistic
#' @return A vector of the permuted test statistic values
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' rec.ccdata.chisq = chisq_per_marker(rec.ccdata$genos[,which(keep==1)],status)
#' rec.ccdata.esm = esm( rec.ccdata.chisq, 50 )
#' rec.ccdata.esm.permdist = esm_perm_binary(rec.ccdata$genos[,which(keep==1)],status,100,50)
esm_perm_binary <- function(ccdata, ccstatus, nperms, k) {
    .Call('buRden_esm_perm_binary', PACKAGE = 'buRden', ccdata, ccstatus, nperms, k)
}

#' Association stat from Thornton, Foran, and Long (2013) PLoS Genetics
#' @param scores A vector of single-marker association test scores, on a -log10 scale
#' @param K the number of markers used to calculate ESM_K
#' @return The ESM_K test statistic value
#' @note See http://www.ncbi.nlm.nih.gov/pubmed/23437004 for detail on the test statistic
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' rec.ccdata.chisq = chisq_per_marker(rec.ccdata$genos[,which(keep==1)],status)
#' rec.ccdata.esm = esm( rec.ccdata.chisq, 50 )
esm <- function(scores, K) {
    .Call('buRden_esm', PACKAGE = 'buRden', scores, K)
}

#' Apply frequency and LD filters to a genotype matrix
#' @param ccdata A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param ccstatus A vector of binary phenotype labels.  0 = control, 1 = case.
#' @param minfreq A site with minor allele frequency < minfreq will not be kept.
#' @param maxfreq A site with minor allele frequency > maxfreq will not be kept.
#' @param rsq_cutoff  When comparing two sites, if the genotype correlation coefficient r^2 is >= rsq_cutoff, only the first site will be kept.
#' @return A vector of integers containing the values 0 (not kept) and 1 (kept).  The length of the vector is equal to the number of columns in ccdata.
#' @details Regarding rsq_cutoff, when sites i and j are compared (j > i), site i will be kept and site j will not be kept.
#' @examples
#' data(rec.ccdata)
#' status=c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' keep=filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
filter_sites <- function(ccdata, ccstatus, minfreq, maxfreq, rsq_cutoff) {
    .Call('buRden_filter_sites', PACKAGE = 'buRden', ccdata, ccstatus, minfreq, maxfreq, rsq_cutoff)
}

#' Get permutation distribution of Madsen-Browning test statistics
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' mbstats = MBstat( rec.ccdata$genos[,which(keep==1)], status )
#' mbstats.perm = MB_perm( rec.ccdata$genos[,which(keep==1)], status, 100 )
MB_perm <- function(ccdata, ccstatus, nperms) {
    .Call('buRden_MB_perm', PACKAGE = 'buRden', ccdata, ccstatus, nperms)
}

#' Calculate Madsen-Browning weights.
#' @param data A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param status A vector of binary phenotype labels.  0 = control, 1 = case.
#' @return An array of weights, one for each column in data.
#' @details Calculation is done under the "general genetic model" defined in Madsen and Browning.
MBweights <- function(data, status) {
    .Call('buRden_MBweights', PACKAGE = 'buRden', data, status)
}

#' Madsen-Browning test statistics
#' @param data A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param status A vector of binary phenotype labels.  0 = control, 1 = case.
#' @return The M-B test statistic for the "general genetic", "recessive", and "dominant" models.
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' mbstats = MBstat( rec.ccdata$genos[,which(keep==1)], status )
MBstat <- function(data, status) {
    .Call('buRden_MBstat', PACKAGE = 'buRden', data, status)
}

#' Pearson's product-moment correlation
#' @param x A vector of values.
#' @param y A vector of values.
#' @return The correlation coefficient between x and y. This should/will be equal to R's cor(x,y).
#' @note This implementation is based on a copy of [libsequence's](http://github.com/molpopgen/libsequence) template function object Sequence::ProductMoment in <Sequence/Correlations.hpp>
#' @examples
#' x=rnorm(100)
#' y=rnorm(100)
#' xy.pm = ProductMoment(x,y)
#' xy.cor = cor(x,y)
#' print( xy.pm - xy.cor )
ProductMoment <- function(x, y) {
    .Call('buRden_ProductMoment', PACKAGE = 'buRden', x, y)
}

