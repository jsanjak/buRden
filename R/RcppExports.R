# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The c-alpha statistic
#' @param data A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param status A vector of binary phenotype labels.  0 = control, 1 = case.
#' @param normalize Return the statistic divided by the square root of its variance.
#' @param simplecounts See Details.
#' @return The c-alpha test statistic.  If normalize = TRUE, then T/sqrt(Z) is returned, otherwise T is returned.
#' @details  When simplecounts = FALSE, heterozygous and homozygous genotypes are treated as different numbers of observations
#' of the mutation.  In other wordes, simplecounts = FALSE is equivalent to colSums( ccdata[status==1,] ).  When simplecounts=TRUE,
#' all nonzero genotype values are treated as the value 1, equivalent to  apply(data[status==1,], 2, function(x) sum(x>0, na.rm=TRUE)).
#' The latter method is used by the R package AssotesteR.  
#' @examples
#' data(rec.ccdata)
#' status = c( rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases) )
#' #get minor allele freqs in 
#' rec.ccdata.MAFS = colSums( rec.ccdata$genos[which(status==0),] )/(2*rec.ccdata$ncontrols)
#' rec.ccdata.calpha = cAlpha(rec.ccdata$genos[,which(rec.ccdata.MAFS <= 0.05)],status)
cAlpha <- function(data, status, normalize = FALSE, simplecounts = FALSE) {
    .Call('buRden_cAlpha', PACKAGE = 'buRden', data, status, normalize, simplecounts)
}

#' Permutation distribution of the c-alpha statistic
#' @param data A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param status A vector of binary phenotype labels.  0 = control, 1 = case.
#' @param nperms The number of permutations to perform
#' @return The distribution of the test statistic after nperms swapping of case/control labels
#' @examples
#' data(rec.ccdata)
#' status = c( rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases) )
#' #get minor allele freqs in 
#' rec.ccdata.MAFS = colSums( rec.ccdata$genos[which(status==0),] )/(2*rec.ccdata$ncontrols)
#' rec.ccdata.calpha = cAlpha(rec.ccdata$genos[,which(rec.ccdata.MAFS <= 0.05)],status)
#' rec.ccdata.calpha.permdist = cAlpha_perm(rec.ccdata$genos[,which(rec.ccdata.MAFS <= 0.05)],status,100)
cAlpha_perm <- function(data, status, nperms) {
    .Call('buRden_cAlpha_perm', PACKAGE = 'buRden', data, status, nperms)
}

#' Single-marker association test based on the chi-squared statistic
#' @param ccdata A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param ccstatus A vector of binary phenotype labels.  0 = control, 1 = case.
#' @return A vector of -log10(p-values) from a chi-squared test with one degree of freedom.  The chisq test is based on a 2x2 table of minor vs major allele counts in cases vs. controls.
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #Note that the result should be very very similar to logistic regression under additive model...
#' rec.ccdata.chisq = chisq_per_marker(rec.ccdata$genos, status)
chisq_per_marker <- function(ccdata, ccstatus) {
    .Call('buRden_chisq_per_marker', PACKAGE = 'buRden', ccdata, ccstatus)
}

#' Obtain permutaion distribution of the ESM_K statistic for case/control data
#' @param ccdata A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param ccstatus A vector of binary phenotype labels.  0 = control, 1 = case.
#' @param nperms Number of permutations to perform
#' @param k Number of markers to use for ESM_K statistic
#' @return A vector of the permuted test statistic values
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' rec.ccdata.chisq = chisq_per_marker(rec.ccdata$genos[,which(keep==1)],status)
#' rec.ccdata.esm = esm( rec.ccdata.chisq, 50 )
#' rec.ccdata.esm.permdist = esm_perm_binary(rec.ccdata$genos[,which(keep==1)],status,100,50)
esm_perm_binary <- function(ccdata, ccstatus, nperms, k) {
    .Call('buRden_esm_perm_binary', PACKAGE = 'buRden', ccdata, ccstatus, nperms, k)
}

#' Association stat from Thornton, Foran, and Long (2013) PLoS Genetics
#' @param scores A vector of single-marker association test scores, on a -log10 scale
#' @param K the number of markers used to calculate ESM_K
#' @return The ESM_K test statistic value
#' @note See http://www.ncbi.nlm.nih.gov/pubmed/23437004 for detail on the test statistic
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' rec.ccdata.chisq = chisq_per_marker(rec.ccdata$genos[,which(keep==1)],status)
#' rec.ccdata.esm = esm( rec.ccdata.chisq, 50 )
esm <- function(scores, K) {
    .Call('buRden_esm', PACKAGE = 'buRden', scores, K)
}

#' Apply frequency and LD filters to a genotype matrix
#' @param ccdata A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param ccstatus A vector of binary phenotype labels.  0 = control, 1 = case.
#' @param minfreq A site with minor allele frequency < minfreq will not be kept.
#' @param maxfreq A site with minor allele frequency > maxfreq will not be kept.
#' @param rsq_cutoff  When comparing two sites, if the genotype correlation coefficient r^2 is >= rsq_cutoff, only the first site will be kept.
#' @return A vector of integers containing the values 0 (not kept) and 1 (kept).  The length of the vector is equal to the number of columns in ccdata.
#' @details Regarding rsq_cutoff, when sites i and j are compared (j > i), site i will be kept and site j will not be kept.
#' @examples
#' data(rec.ccdata)
#' status=c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' keep=filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
filter_sites <- function(ccdata, ccstatus, minfreq, maxfreq, rsq_cutoff) {
    .Call('buRden_filter_sites', PACKAGE = 'buRden', ccdata, ccstatus, minfreq, maxfreq, rsq_cutoff)
}

#' Get permutation distribution of Madsen-Browning test statistics
#' @param ccdata A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.                                                                                    
#' @param ccstatus A vector of binary phenotype labels.  0 = control, 1 = case. 
#' @param nperms The number of permutations to perform
#' @return A data frame of permuted statistics
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' mbstats = MBstat( rec.ccdata$genos[,which(keep==1)], status )
#' mbstats.perm = MB_perm( rec.ccdata$genos[,which(keep==1)], status, 100 )
MB_perm <- function(ccdata, ccstatus, nperms) {
    .Call('buRden_MB_perm', PACKAGE = 'buRden', ccdata, ccstatus, nperms)
}

#' Calculate Madsen-Browning weights.
#' @param data A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param status A vector of binary phenotype labels.  0 = control, 1 = case.
#' @return An array of weights, one for each column in data.
#' @details Calculation is done under the "general genetic model" defined in Madsen and Browning.
MBweights <- function(data, status) {
    .Call('buRden_MBweights', PACKAGE = 'buRden', data, status)
}

#' Madsen-Browning test statistics
#' @param data A matrix of markers (columns) and individuals (rows).  Data are coded as the number of copies of the minor allele.
#' @param status A vector of binary phenotype labels.  0 = control, 1 = case.
#' @return The M-B test statistic for the "general genetic", "recessive", and "dominant" models.
#' @examples
#' data(rec.ccdata)
#' status = c(rep(0,rec.ccdata$ncontrols),rep(1,rec.ccdata$ncases))
#' #filter out common alleles and marker pairs in high LD
#' keep = filter_sites(rec.ccdata$genos,status,0,0.05,0.8)
#' mbstats = MBstat( rec.ccdata$genos[,which(keep==1)], status )
MBstat <- function(data, status) {
    .Call('buRden_MBstat', PACKAGE = 'buRden', data, status)
}

#' Pearson's product-moment correlation
#' @param x A vector of values.
#' @param y A vector of values.
#' @return The correlation coefficient between x and y. This should/will be equal to R's cor(x,y).
#' @note This implementation is based on a copy of [libsequence's](http://github.com/molpopgen/libsequence) template function object Sequence::ProductMoment in <Sequence/Correlations.hpp>
#' @examples
#' x=rnorm(100)
#' y=rnorm(100)
#' xy.pm = ProductMoment(x,y)
#' xy.cor = cor(x,y)
#' print( xy.pm - xy.cor )
ProductMoment <- function(x, y) {
    .Call('buRden_ProductMoment', PACKAGE = 'buRden', x, y)
}

